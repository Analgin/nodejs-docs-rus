* Translate 'about' section in index.htm
* Translate small part of module.markdown and dns.markdown

* diff -up ./api_v0.4.9 ./api_v0.4.12:

diff -up ./api_v0.4.9/dgram.markdown ./api_v0.4.12//dgram.markdown
--- ./api_v0.4.9/dgram.markdown	2011-09-21 00:45:30.000000000 +0400
+++ ./api_v0.4.12//dgram.markdown	2011-09-21 00:45:54.000000000 +0400
@@ -186,7 +186,7 @@ packets will also be received on the loc
 
 Tells the kernel to join a multicast group with `IP_ADD_MEMBERSHIP` socket option.
 
-If `multicastAddress` is not specified, the OS will try to add membership to all valid
+If `multicastInterface` is not specified, the OS will try to add membership to all valid
 interfaces.
 
 ### dgram.dropMembership(multicastAddress, [multicastInterface])
@@ -196,5 +196,5 @@ Opposite of `addMembership` - tells the
 when the socket is closed or process terminates, so most apps will never need to call
 this.
 
-If `multicastAddress` is not specified, the OS will try to drop membership to all valid
+If `multicastInterface` is not specified, the OS will try to drop membership to all valid
 interfaces.
diff -up ./api_v0.4.9/fs.markdown ./api_v0.4.12//fs.markdown
--- ./api_v0.4.9/fs.markdown	2011-09-21 00:45:30.000000000 +0400
+++ ./api_v0.4.12//fs.markdown	2011-09-21 00:45:54.000000000 +0400
@@ -52,6 +52,9 @@ In busy processes, the programmer is _st
 asynchronous versions of these calls. The synchronous versions will block
 the entire process until they complete--halting all connections.
 
+Relative path to filename can be used, remember however that this path will be relative
+to `process.cwd()`.
+
 ### fs.rename(path1, path2, [callback])
 
 Asynchronous rename(2). No arguments other than a possible exception are given
@@ -70,6 +73,33 @@ given to the completion callback.
 
 Synchronous ftruncate(2).
 
+### fs.chown(path, uid, gid, [callback])
+
+Asycnronous chown(2). No arguments other than a possible exception are given
+to the completion callback.
+
+### fs.chownSync(path, uid, gid)
+
+Synchronous chown(2).
+
+### fs.fchown(path, uid, gid, [callback])
+
+Asycnronous fchown(2). No arguments other than a possible exception are given
+to the completion callback.
+
+### fs.fchownSync(path, uid, gid)
+
+Synchronous fchown(2).
+
+### fs.lchown(path, uid, gid, [callback])
+
+Asycnronous lchown(2). No arguments other than a possible exception are given
+to the completion callback.
+
+### fs.lchownSync(path, uid, gid)
+
+Synchronous lchown(2).
+
 ### fs.chmod(path, mode, [callback])
 
 Asynchronous chmod(2). No arguments other than a possible exception are given
@@ -79,6 +109,24 @@ to the completion callback.
 
 Synchronous chmod(2).
 
+### fs.fchmod(fd, mode, [callback])
+
+Asynchronous fchmod(2). No arguments other than a possible exception
+are given to the completion callback.
+
+### fs.fchmodSync(path, mode)
+
+Synchronous fchmod(2).
+
+### fs.lchmod(fd, mode, [callback])
+
+Asynchronous lchmod(2). No arguments other than a possible exception
+are given to the completion callback.
+
+### fs.lchmodSync(path, mode)
+
+Synchronous lchmod(2).
+
 ### fs.stat(path, [callback])
 
 Asynchronous stat(2). The callback gets two arguments `(err, stats)` where
@@ -210,8 +258,27 @@ Synchronous close(2).
 
 ### fs.open(path, flags, [mode], [callback])
 
-Asynchronous file open. See open(2). Flags can be 'r', 'r+', 'w', 'w+', 'a',
-or 'a+'. `mode` defaults to 0666. The callback gets two arguments `(err, fd)`.
+Asynchronous file open. See open(2). `flags` can be:
+
+* `'r'` - Open file for reading.
+An exception occurs if the file does not exist.
+
+* `'r+'` - Open file for reading and writing. 
+An exception occurs if the file does not exist.
+
+* `'w'` - Open file for writing.
+The file is created (if it does not exist) or truncated (if it exists).
+
+* `'w+'` - Open file for reading and writing.
+The file is created (if it does not exist) or truncated (if it exists).
+
+* `'a'` - Open file for appending.
+The file is created if it does not exist.
+
+* `'a+'` - Open file for reading and appending.
+The file is created if it does not exist.
+
+`mode` defaults to `0666`. The callback gets two arguments `(err, fd)`.
 
 ### fs.openSync(path, flags, [mode])
 
@@ -321,7 +388,7 @@ value in milliseconds. The default is `{
 The `listener` gets two arguments the current stat object and the previous
 stat object:
 
-    fs.watchFile(f, function (curr, prev) {
+    fs.watchFile('message.text', function (curr, prev) {
       console.log('the current mtime is: ' + curr.mtime);
       console.log('the previous mtime was: ' + prev.mtime);
     });
@@ -329,7 +396,7 @@ stat object:
 These stat objects are instances of `fs.Stat`.
 
 If you want to be notified when the file was modified, not just accessed
-you need to compare `curr.mtime` and `prev.mtime.
+you need to compare `curr.mtime` and `prev.mtime`.
 
 
 ### fs.unwatchFile(filename)
@@ -353,6 +420,12 @@ Objects returned from `fs.stat()` and `f
 
 `ReadStream` is a `Readable Stream`.
 
+### Event: 'open'
+
+`function (fd) { }`
+
+ `fd` is the file descriptor used by the ReadStream.
+
 ### fs.createReadStream(path, [options])
 
 Returns a new ReadStream object (See `Readable Stream`).
diff -up ./api_v0.4.9/globals.markdown ./api_v0.4.12//globals.markdown
--- ./api_v0.4.9/globals.markdown	2011-09-21 00:45:30.000000000 +0400
+++ ./api_v0.4.12//globals.markdown	2011-09-21 00:45:54.000000000 +0400
@@ -79,6 +79,15 @@ A reference to the current module. In pa
 for more information.
 `module` isn't actually a global but rather local to each module.
 
+
+### exports
+
+An object which is shared between all instances of the current module and
+made accessible through `require()`.
+`exports` is the same as the `module.exports` object. See `src/node.js`
+for more information.
+`exports` isn't actually a global but rather local to each module.
+
 ### setTimeout(cb, ms)
 ### clearTimeout(t)
 ### setInterval(cb, ms)
diff -up ./api_v0.4.9/http.markdown ./api_v0.4.12//http.markdown
--- ./api_v0.4.9/http.markdown	2011-09-21 00:45:30.000000000 +0400
+++ ./api_v0.4.12//http.markdown	2011-09-21 00:45:54.000000000 +0400
@@ -38,11 +38,11 @@ per connection (in the case of keep-aliv
 
 ### Event: 'connection'
 
-`function (stream) { }`
+`function (socket) { }`
 
- When a new TCP stream is established. `stream` is an object of type
- `net.Stream`. Usually users will not want to access this event. The
- `stream` can also be accessed at `request.connection`.
+ When a new TCP stream is established. `socket` is an object of type
+ `net.Socket`. Usually users will not want to access this event. The
+ `socket` can also be accessed at `request.connection`.
 
 ### Event: 'close'
 
@@ -52,7 +52,7 @@ per connection (in the case of keep-aliv
 
 ### Event: 'checkContinue'
 
-`function (request, response) {}`
+`function (request, response) { }`
 
 Emitted each time a request with an http Expect: 100-continue is received.
 If this event isn't listened for, the server will automatically respond
@@ -68,7 +68,7 @@ not be emitted.
 
 ### Event: 'upgrade'
 
-`function (request, socket, head)`
+`function (request, socket, head) { }`
 
 Emitted each time a client requests a http upgrade. If this event isn't
 listened for, then clients requesting an upgrade will have their connections
@@ -84,7 +84,7 @@ sent to the server on that socket.
 
 ### Event: 'clientError'
 
-`function (exception) {}`
+`function (exception) { }`
 
 If a client connection emits an 'error' event - it will forwarded here.
 
@@ -239,7 +239,7 @@ Resumes a paused request.
 
 ### request.connection
 
-The `net.Stream` object associated with the connection.
+The `net.Socket` object associated with the connection.
 
 
 With HTTPS support, use request.connection.verifyPeer() and
@@ -283,6 +283,8 @@ Note: that Content-Length is given in by
 works because the string `'hello world'` contains only single byte characters.
 If the body contains higher coded characters then `Buffer.byteLength()`
 should be used to determine the number of bytes in a given encoding.
+And Node does not check whether Content-Length and the length of the body
+which has been transmitted are equal or not.
 
 ### response.statusCode
 
@@ -294,6 +296,9 @@ Example:
 
     response.statusCode = 404;
 
+After response header was sent to the client, this property indicates the
+status code which was sent out.
+
 ### response.setHeader(name, value)
 
 Sets a single header value for implicit headers.  If this header already exists
@@ -393,6 +398,10 @@ Options:
 - `path`: Request path. Should include query string and fragments if any.
    E.G. `'/index.html?page=12'`
 - `headers`: An object containing request headers.
+- `agent`: Controls `Agent` behavior. Possible values:
+ - `undefined` (default): use default `Agent` for this host and port.
+ - `Agent` object: explicitly use the passed in `Agent`.
+ - `false`: explicitly generate a new `Agent` for this host and port. `Agent` will not be re-used.
 
 `http.request()` returns an instance of the `http.ClientRequest`
 class. The `ClientRequest` instance is a writable stream. If one needs to
@@ -476,7 +485,7 @@ agent. The `http.getAgent()` function al
 
 ### Event: 'upgrade'
 
-`function (response, socket, head)`
+`function (response, socket, head) { }`
 
 Emitted each time a server responds to a request with an upgrade. If this
 event isn't being listened for, clients receiving an upgrade header will have
@@ -530,14 +539,6 @@ A client server pair that show you how t
     });
 
 
-### Event: 'continue'
-
-`function ()`
-
-Emitted when the server sends a '100 Continue' HTTP response, usually because
-the request contained 'Expect: 100-continue'. This is an instruction that
-the client should send the request body.
-
 ### agent.maxSockets
 
 By default set to 5. Determines how many concurrent sockets the agent can have open.
@@ -590,9 +591,19 @@ event, the entire body will be caught.
     });
 
 This is a `Writable Stream`.
+Note: Node does not check whether Content-Length and the length of the body
+which has been transmitted are equal or not.
 
 This is an `EventEmitter` with the following events:
 
+### Event: 'continue'
+
+`function () { }`
+
+Emitted when the server sends a '100 Continue' HTTP response, usually because
+the request contained 'Expect: 100-continue'. This is an instruction that
+the client should send the request body.
+
 ### Event 'response'
 
 `function (response) { }`
@@ -639,18 +650,27 @@ The response implements the `Readable St
 
 ### Event: 'data'
 
-`function (chunk) {}`
+`function (chunk) { }`
 
 Emitted when a piece of the message body is received.
 
 
 ### Event: 'end'
 
-`function () {}`
+`function () { }`
 
 Emitted exactly once for each message. No arguments. After
 emitted no other events will be emitted on the response.
 
+### Event: 'close'
+
+`function (err) { }`
+
+Indicates that the underlaying connection was terminated before
+`end` event was emitted.
+See [http.ServerRequest](#http.ServerRequest)'s `'close'` event for more
+information.
+
 ### response.statusCode
 
 The 3-digit HTTP response status code. E.G. `404`.
diff -up ./api_v0.4.9/modules.markdown ./api_v0.4.12//modules.markdown
--- ./api_v0.4.9/modules.markdown	2011-09-21 00:45:30.000000000 +0400
+++ ./api_v0.4.12//modules.markdown	2011-09-21 00:45:54.000000000 +0400
@@ -248,9 +248,10 @@ Loading from the `require.paths` locatio
 module could not be found using the `node_modules` algorithm above.
 Global modules are lower priority than bundled dependencies.
 
-#### **Note:** Please Avoid Modifying `require.paths`
+#### **Note:** Please Avoid Using `require.paths`
 
-`require.paths` may disappear in a future release.
+`require.paths` will only be supported through the end of the v0.4
+stable branch.  It is removed from node as of v0.5.
 
 While it seemed like a good idea at the time, and enabled a lot of
 useful experimentation, in practice a mutable `require.paths` list is
@@ -294,21 +295,6 @@ predict.
 
 ### Accessing the main module
 
-When a file is run directly from Node, `require.main` is set to its
-`module`. That means that you can determine whether a file has been run
-directly by testing
-
-    require.main === module
-
-For a file `foo.js`, this will be `true` if run via `node foo.js`, but
-`false` if run by `require('./foo')`.
-
-Because `module` provides a `filename` property (normally equivalent to
-`__filename`), the entry point of the current application can be obtained
-by checking `require.main.filename`.
-
-### Accessing the main module
-
 When a file is run directly from Node, `require.main` is set to its
 `module`. That means that you can determine whether a file has been run
 directly by testing
diff -up ./api_v0.4.9/process.markdown ./api_v0.4.12//process.markdown
--- ./api_v0.4.9/process.markdown	2011-09-21 00:45:30.000000000 +0400
+++ ./api_v0.4.12//process.markdown	2011-09-21 00:45:54.000000000 +0400
@@ -280,7 +280,8 @@ What platform you're running on. `'linux
 
 ### process.memoryUsage()
 
-Returns an object describing the memory usage of the Node process.
+Returns an object describing the memory usage of the Node process
+measured in bytes.
 
     var util = require('util');
 
diff -up ./api_v0.4.9/readline.markdown ./api_v0.4.12//readline.markdown
--- ./api_v0.4.9/readline.markdown	2011-09-21 00:45:30.000000000 +0400
+++ ./api_v0.4.12//readline.markdown	2011-09-21 00:45:54.000000000 +0400
@@ -0,0 +1,133 @@
+## Readline
+
+To use this module, do `require('readline')`. Readline allows reading of a
+stream (such as STDIN) on a line-by-line basis.
+
+Note that once you've invoked this module, your node program will not
+terminate until you've closed the interface, and the STDIN stream. Here's how
+to allow your program to gracefully terminate:
+
+    var rl = require('readline');
+
+    var i = rl.createInterface(process.sdtin, process.stdout, null);
+    i.question("What do you think of node.js?", function(answer) {
+      // TODO: Log the answer in a database
+      console.log("Thank you for your valuable feedback.");
+
+      // These two lines together allow the program to terminate. Without
+      // them, it would run forever.
+      i.close();
+      process.stdin.destroy();
+    });
+
+### rl.createInterface(input, output, completer)
+
+Takes two streams and creates a readline interface. The `completer` function
+is used for autocompletion. When given a substring, it returns `[[substr1,
+substr2, ...], originalsubstring]`.
+
+`createInterface` is commonly used with `process.stdin` and
+`process.stdout` in order to accept user input:
+
+    var readline = require('readline'),
+      rl = readline.createInterface(process.stdin, process.stdout);
+
+### rl.setPrompt(prompt, length)
+
+Sets the prompt, for example when you run `node` on the command line, you see
+`> `, which is node's prompt.
+
+### rl.prompt()
+
+Readies readline for input from the user, putting the current `setPrompt`
+options on a new line, giving the user a new spot to write.
+
+<!-- ### rl.getColumns() Not available? -->
+
+### rl.question(query, callback)
+
+Prepends the prompt with `query` and invokes `callback` with the user's
+response. Displays the query to the user, and then invokes `callback` with the
+user's response after it has been typed.
+
+Example usage:
+
+    interface.question('What is your favorite food?', function(answer) {
+      console.log('Oh, so your favorite food is ' + answer);
+    });
+
+### rl.close()
+
+  Closes tty.
+
+### rl.pause()
+
+  Pauses tty.
+
+### rl.resume()
+
+  Resumes tty.
+
+### rl.write()
+
+  Writes to tty.
+
+### Event: 'line'
+
+`function (line) {}`
+
+Emitted whenever the `in` stream receives a `\n`, usually received when the
+user hits enter, or return. This is a good hook to listen for user input.
+
+Example of listening for `line`:
+
+    rl.on('line', function (cmd) {
+      console.log('You just typed: '+cmd);
+    });
+
+### Event: 'close'
+
+`function () {}`
+
+Emitted whenever the `in` stream receives a `^C` or `^D`, respectively known
+as `SIGINT` and `EOT`. This is a good way to know the user is finished using
+your program.
+
+Example of listening for `close`, and exiting the program afterward:
+
+    rl.on('close', function() {
+      console.log('goodbye!');
+      process.exit(0);
+    });
+
+Here's an example of how to use all these together to craft a tiny command
+line interface:
+
+    var readline = require('readline'),
+      rl = readline.createInterface(process.stdin, process.stdout),
+      prefix = 'OHAI> ';
+
+    rl.on('line', function(line) {
+      switch(line.trim()) {
+        case 'hello':
+          console.log('world!');
+          break;
+        default:
+          console.log('Say what? I might have heard `' + line.trim() + '`');
+          break;
+      }
+      rl.setPrompt(prefix, prefix.length);
+      rl.prompt();
+    }).on('close', function() {
+      console.log('Have a great day!');
+      process.exit(0);
+    });
+    console.log(prefix + 'Good to see you. Try typing stuff.');
+    rl.setPrompt(prefix, prefix.length);
+    rl.prompt();
+
+
+Take a look at this slightly more complicated
+[example](https://gist.github.com/901104), and
+[http-console](http://github.com/cloudhead/http-console) for a real-life use
+case.
\ В конце файла нет новой строки
Только в ./api_v0.4.9: readline.md
diff -up ./api_v0.4.9/stdio.markdown ./api_v0.4.12//stdio.markdown
--- ./api_v0.4.9/stdio.markdown	2011-09-21 00:45:30.000000000 +0400
+++ ./api_v0.4.12//stdio.markdown	2011-09-21 00:45:54.000000000 +0400
@@ -9,8 +9,30 @@ Prints to stdout with newline. This func
 
     console.log('count: %d', count);
 
-If formating elements are not found in the first string then `util.inspect`
-is used on each argument.
+The first argument is a string that contains zero or more *placeholders*.
+Each placeholder is replaced with the converted value from its corresponding
+argument. Supported placeholders are:
+
+* `%s` - String.
+* `%d` - Number (both integer and float).
+* `%j` - JSON.
+
+If the placeholder does not have a corresponding argument, `undefined` is used.
+
+    console.log('%s:%s', 'foo'); // 'foo:undefined'
+
+If there are more arguments than placeholders, the extra arguments are
+converted to strings with `util.inspect()` and these strings are concatenated,
+delimited by a space.
+
+    console.log('%s:%s', 'foo', 'bar', 'baz'); // 'foo:bar baz'
+
+If the first argument is not a format string then `console.log()` prints
+a string that is the concatenation of all its arguments separated by spaces.
+Each argument is converted to a string with `util.inspect()`.
+
+    console.log(1, 2, 3); // '1 2 3'
+
 
 ### console.info()
 
@@ -35,7 +57,7 @@ Mark a time.
 Finish timer, record output. Example
 
     console.time('100-elements');
-    while (var i = 0; i < 100; i++) {
+    for (var i = 0; i < 100; i++) {
       ;
     }
     console.timeEnd('100-elements');
diff -up ./api_v0.4.9/tls.markdown ./api_v0.4.12//tls.markdown
--- ./api_v0.4.9/tls.markdown	2011-09-21 00:45:30.000000000 +0400
+++ ./api_v0.4.12//tls.markdown	2011-09-21 00:45:54.000000000 +0400
@@ -42,13 +42,13 @@ defaults to `localhost`.) `options` shou
     omitted several well known "root" CAs will be used, like VeriSign.
     These are used to authorize connections.
 
-`tls.connect()` returns a cleartext `CryptoStream` object.
+`tls.connect()` returns a [CleartextStream](#tls.CleartextStream) object.
 
 After the TLS/SSL handshake the `callback` is called. The `callback` will be
 called no matter if the server's certificate was authorized or not. It is up
-to the user to test `s.authorized` to see if the server certificate was
-signed by one of the specified CAs. If `s.authorized === false` then the error
-can be found in `s.authorizationError`.
+to the user to test `s.authorized` to see if the server certificate was signed
+by one of the specified CAs. If `s.authorized === false` then the error can be
+found in `s.authorizationError`.
 
 
 ### STARTTLS
@@ -56,13 +56,42 @@ can be found in `s.authorizationError`.
 In the v0.4 branch no function exists for starting a TLS session on an
 already existing TCP connection.  This is possible it just requires a bit of
 work. The technique is to use `tls.createSecurePair()` which returns two
-streams: an encrypted stream and a plaintext stream. The encrypted stream is then
-piped to the socket, the plaintext stream is what the user interacts with thereafter.
+streams: an encrypted stream and a cleartext stream. The encrypted stream is
+then piped to the socket, the cleartext stream is what the user interacts with
+thereafter.
 
 [Here is some code that does it.](http://gist.github.com/848444)
 
+### pair = tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])
 
+Creates a new secure pair object with two streams, one of which reads/writes
+encrypted data, and one reads/writes cleartext data.
+Generally the encrypted one is piped to/from an incoming encrypted data stream,
+and the cleartext one is used as a replacement for the initial encrypted stream.
 
+ - `credentials`: A credentials object from crypto.createCredentials( ... )
+
+ - `isServer`: A boolean indicating whether this tls connection should be
+   opened as a server or a client.
+
+ - `requestCert`: A boolean indicating whether a server should request a
+   certificate from a connecting client. Only applies to server connections.
+
+ - `rejectUnauthorized`: A boolean indicating whether a server should
+   automatically reject clients with invalid certificates. Only applies to
+   servers with `requestCert` enabled.
+
+`tls.createSecurePair()` returns a SecurePair object with
+[cleartext](#tls.CleartextStream) and `encrypted` stream properties.
+
+#### Event: 'secure'
+
+The event is emitted from the SecurePair once the pair has successfully
+established a secure connection.
+
+Similarly to the checking for the server 'secureConnection' event,
+pair.cleartext.authorized should be checked to confirm whether the certificate
+used properly authorized.
 
 ### tls.Server
 
@@ -121,8 +150,9 @@ has these possibilities:
 `function (cleartextStream) {}`
 
 This event is emitted after a new connection has been successfully
-handshaked. The argument is a duplex instance of `stream.Stream`. It has all
-the common stream methods and events.
+handshaked. The argument is a instance of
+[CleartextStream](#tls.CleartextStream). It has all the common stream methods
+and events.
 
 `cleartextStream.authorized` is a boolean value which indicates if the
 client has verified by one of the supplied certificate authorities for the
@@ -153,8 +183,57 @@ event.
 
 #### server.maxConnections
 
-Set this property to reject connections when the server's connection count gets high.
+Set this property to reject connections when the server's connection count
+gets high.
 
 #### server.connections
 
 The number of concurrent connections on the server.
+
+
+### tls.CleartextStream
+
+This is a stream on top of the *Encrypted* stream that makes it possible to
+read/write an encrypted data as a cleartext data.
+
+This instance implements a duplex [Stream](streams.html#streams) interfaces.
+It has all the common stream methods and events.
+
+#### cleartextStream.authorized
+
+A boolean that is `true` if the peer certificate was signed by one of the
+specified CAs, otherwise `false`
+
+#### cleartextStream.authorizationError
+
+The reason why the peer's certificate has not been verified. This property
+becomes available only when `cleartextStream.authorized === false`.
+
+#### cleartextStream.getPeerCertificate()
+
+Returns an object representing the peer's certicicate. The returned object has
+some properties corresponding to the field of the certificate.
+
+Example:
+
+    { subject: 
+       { C: 'UK',
+         ST: 'Acknack Ltd',
+         L: 'Rhys Jones',
+         O: 'node.js',
+         OU: 'Test TLS Certificate',
+         CN: 'localhost' },
+      issuer: 
+       { C: 'UK',
+         ST: 'Acknack Ltd',
+         L: 'Rhys Jones',
+         O: 'node.js',
+         OU: 'Test TLS Certificate',
+         CN: 'localhost' },
+      valid_from: 'Nov 11 09:52:22 2009 GMT',
+      valid_to: 'Nov  6 09:52:22 2029 GMT',
+      fingerprint: '2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF' }
+
+If the peer does not provide a certificate, it returns `null` or an empty
+object.
+
