## Сеть

Модуль `net` предоставляет асинхронные методы для работы с сетью. Он включает
методы для создания как серверов, так и клиентов (называемых потоками).
Вы может использовать этот модуль вызвав `require("net")`.

### net.createServer(connectionListener)

Создаёт новый TCP сервер. Аргумент `connection_listener` автоматически
становится обработчиком события `'connection'`.

### net.createConnection(arguments...)

Создаёт новый объект потока. Когда соединение установлено, будет сгенерировано
событие `'connect'`.

Аргументы для этого метода определяются тепим соединения:

* `net.createConnection(port, [host])`

  Открывает TCP-соединение с указанным портом `port` и адресом `host`.
  Если второй параметр не задан, предполагается значение `localhost`.

* `net.createConnection(path)`

  Создаёт соединение с Unix-сокетом `path`.

---

### net.Server

Этот класс используется для создания TCP или UNIX сервера.

Вот простой пример сервера, который возвращает полученный запрос
и слушает на порту 8124:

    var net = require('net');
    var server = net.createServer(function (stream) {
      stream.setEncoding('utf8');
      stream.on('connect', function () {
        stream.write('hello\r\n');
      });
      stream.on('data', function (data) {
        stream.write(data);
      });
      stream.on('end', function () {
        stream.write('goodbye\r\n');
        stream.end();
      });
    });
    server.listen(8124, 'localhost');

Чтобы слушать сокет `'/tmp/echo.sock'`, последнюю строку надо заменить на

    server.listen('/tmp/echo.sock');

#### server.listen(port, [host], [callback])

Начинает принимать соединения на указанном порту `port` и имени хоста `host`.
Если `host` пропущен, сервер будет принимать соединения
на каждом IPv4-адресе (INADDR_ANY).

Эта функция асинхронна. Последний параметр `callback` будет вызван когда сервер
начнёт принимать соединения.

#### server.listen(path, [callback])

Запускает сервер слушающий UNIX-сокет по указанному адресу `path`.

Эта функция асинхронна. Последний параметр `callback` будет вызван когда сервер
начнёт принимать соединения.

#### server.listenFD(fd)

Запускает сервер, слушающий указанный файловый дескриптор.

Для указанного файлового дескриптора должны быть уже выполнены
системные вызовы `bind(2)` и `listen(2)`.

#### server.close()

Прекращает приём соединений сервером. Эта функция асинхронна,
сервер полностью закрывается только после генерации события `'close'`.


#### server.address()

Возвращает адрес, к которому привязан сервер. Удобно использовать, если выбор
адреса предоставляется системе.

Пример:

    var server = net.createServer(function (socket) {
      socket.end("goodbye\n");
    });

    // grab a random port.
    server.listen(function() {
      address = server.address();
      console.log("opened server on %j", address);
    });


#### server.maxConnections

Установите это свойство, если хотите запретить серверу принимать
больше определённого числа соединений единовременно.

#### server.connections

Текущее число соединений с сервером.

---

`net.Server` — экземпляр `EventEmitter` со следующими событиями:

#### Событие: 'connection'

`function (stream) {}`

Генерируется при новом соединении. `stream` — экземпляр `net.Stream`.

#### Событие: 'close'

`function () {}`

Генерируется при завершении работы сервера.

---

### net.Stream

Этот объект — абстракция TCP порта или UNIX сокета. Экземпляр `net.Stream`
имеет возможность как чтения, так и записи. Он может быть создан и использован
как клиентом (с помощью `connect()`) либо создан внутри Node и передан
пользователю через обработчик события `'connection'`.

#### stream.connect(port, [host])
#### stream.connect(path)

Открывает TCP-соединение с указанным портом `port` и адресом `host`. Если второй
параметр не задан, предполагается значение `localhost`. Если указан параметр
`path`, то создаёт соединение с Unix-сокетом `path`.

Обычно этот метод не нужен. Используйте его только если поток закрыт и вы хотите
повторно использовать тот же объект для соединения с другим сервером.

Эта функция асинхронна. Когда генерируется событие `'connect'`, соединение
установлено. Если при соединении возникли проблемы, событие `'connect'`
не будет сгенерировано, вместо него будет сгенерировано событие `'error'`
с аргументом исключения.


#### stream.setEncoding(encoding=null)

Задаёт кодировку (`'ascii'`, `'utf8'` или `'base64'`) для принимаемых данных.

#### stream.setSecure([credentials])

Включает поддержку HTTPS для потока, параметры передаются криптографическому
модулю и включают private key и сертификат потока, дополнительно могут включать
сертификаты CA для аутентификации участника соединения.

Если объект параметров содержит один или несколько сертификатов CA, поток
запросит у участника соединения сертификат в ходе установки HTTPS-соединения.
Правильность и содержимое сертификата могут быть проверены функциями
`verifyPeer()` и `getPeerCertificate()`.

#### stream.verifyPeer()

Возвращает `true` или `false` в зависимости от правильности сертификата участника
соединения в контексте заданных CA-сертификатов (или списка CA по умолчанию).

#### stream.getPeerCertificate()

Возвращает JSON с деталями сертификата участника соединения, содержащий свойства
`'subject'`, `'issuer'`, `'valid_from'` и `'valid_to'`.

#### stream.write(data, encoding='ascii')

Отправляет данные в поток. Второй параметр означает кодировку, если первым
параметром передана строка. По умолчанию используется ASCII т.к. кодирование
в UTF-8 довольно медленно.

Возвращает `true` если все данные были успешно переданы в буфер ядра. Возвращает
`false` если все данные или их часть были помещены в очередь в памяти. Событие
`'drain'` будет сгенерировано когда буфер ядра снова будет пуст.

#### stream.end([data], [encoding])

Наполовину закрывает соединение, т.е. отправляет пакет FIN. Возможно сервер ещё
получит какие-то данные. После вызова этого метода свойство `readyState` будет
установлено в значение `'readOnly'`.

Если определён аргумент `data`, то этот вызов эквивалентен последовательному вызову
`stream.write(data, encoding)` и `stream.end()`.

#### stream.destroy()

Закрывает поток таким образом чтобы в нём больше не происходило ввода-вывода.
Необходимо только для закрытия соединения в случае серьёзных ошибок.

#### stream.pause()

Приостанавливает чтение данных. Т.е. события 'data' не будут генерироваться.
Используется при приёме файлов.

#### stream.resume()

Возобновляет чтение данных после вызова pause().

#### stream.setTimeout(timeout)

Устанавливает таймаут в `timeout` миллисекунд бездействия потока. По умолчанию
`net.Stream` не имеет таймаута.

Если поток не будет проявлять активности указанное количество миллисекунд будет
сгенерировано событие `'timeout'`, но само соединение не будет затронуто.
Пользователь должен самостоятельно вызвать `end()` или `destroy()` для закрытия потока.

Если в качестве `timeout` передан 0, существующий таймаут перестаёт действовать.

#### stream.setNoDelay(noDelay=true)

Выключает алгоритм Нагла. По умолчанию TCP-соединения используют алгоритм Нагла,
собирая данные в буфер перед отправкой. Установка noDelay приведёт к немедленной
отправке всех данных, передаваемых в `stream.write()`.

#### stream.setKeepAlive(enable=false, [initialDelay])

Включает/выключает функционал keep-alive, и дополнительно позволяет установить
начальную задержку после которой будет отправлен первый пакет проверки соединения
при неактивности. Значение `initialDelay` (в миллисекундах) означает интервал
между последним отправленным пакетом и первой проверкой соединения. Установка
`initialDelay` в 0 оставит в силе предыдущее значение.

#### stream.remoteAddress

Строковое представление удалённого IP адреса. Например, `'74.125.127.100'` или
`'2001:4860:a005::68'`.

Это ствойство доступно тольок для соединений сервер-сервер.

#### stream.readyState

Текущий статус потока, может равняться `'closed'`, `'open'`, `'opening'`,
`'readOnly'` или `'writeOnly'`.

---

Экземпляры `net.Stream` — экземпляры `EventEmitter` со следующими событиями:

#### Событие: 'connect'

`function () { }`

Генерируется после успешной установки соединения. См. `connect()`.


#### Событие: 'secure'

`function () { }`

Генерируется когда соединение успешно проходит HTTPS-аутентификацию клиента.


#### Событие: 'data'

`function (data) { }`

Генерируется при приёме данных. Аргумент `data` будет экземпляром `Buffer`
или `String`. Кодировка передаваемых данных устанавливается методом
`stream.setEncoding()`. (См. секцию о `потоках с возможностью чтения` для
более подробной информации.)

#### Событие: 'end'

`function () { }`

Генерируется когда другой участник соединения посылает пакет FIN.

По умолчанию (`allowHalfOpen == false`) поток уничтожает свой файловый дескриптор
после завершения обработки очереди записи. Но если установить `allowHalfOpen == true`,
то поток не будет автоматически завершаться (`end()`), т.е. пользоввателю
требуется вручную вызвать `end()`. В случае `allowHalfOpen == true` после
генерации этого события свойство readyState будет установлено в значение 'writeOnly'.


#### Событие: 'timeout'

`function () { }`

Генерируется если поток долгое время не используется. Это просто уведомление
о длительной неактивности потока. Пользователь должен сам закрыть соединение.

См. также: `stream.setTimeout()`.


#### Событие: 'drain'

`function () { }`

Генерируется когда буфер записи становится пустым (все данные, переданные в поток,
были отправлены получателю). Может быть использоваться для отправки файлов.

#### Событие: 'error'

`function (exception) { }`

Генерируется при возникновении ошибки. Сразу после этого будет сгенерировано
событие `'close'`.

#### Событие: 'close'

`function (had_error) { }`

Генерируется один раз когда поток полностью закрывается. Аргумент had_error —
двоичное значение, устанавливаемое в true если поток был закрыт из за ошибки передачи.

---

### net.isIP

#### net.isIP(input)

Проверяет. является ли `input` валидным IP адресом. Возвращает 0 для неверных строк,
4 для IPv4 адресов и 6 для IPv6 адресов.


#### net.isIPv4(input)

Возвращает `true` если `input` является IPv4 адресов, в осатльных случаях `false`.


#### net.isIPv6(input)

Возвращает `true` если `input` является IPv6 адресов, в осатльных случаях `false`.

