## C/C++ дополнения

Дополнения — это динамически подключаемые объекты. Они могут предоставлять
связь с библиотеками на языках C/C++. На данный момент API для дополнений
довольно сложное и использует следующие библиотеки:

 - Движок V8 JavaScript, написан на C++. Используется для обращения к JavaScript
   из дополнения: создания объектов, вызова функций и т.д. Документация по нему
   крайне скудна, в основном стоит полагаться на заголовочный файл `v8.h`
   (`deps/v8/include/v8.h` в дистрибутиве Node).

 - libev, библиотеку обработки цикла событий на C. Каждый раз, когда вам
   потребуется подождать пока файловый дескриптор станет доступен для чтения,
   подождать вызова таймера или поступления сигнала, вы будете испльзовать
   вызовы из libev. Соответственно, вам придётся использовать libev для любых
   операций ввода/вывода. Node использует цикл событий `EV_DEFAULT`.
   Документация доступна на [сайте автора](http://cvs.schmorp.de/libev/ev.html).

 - libeio, библиотеку пула потоков на C. Она используется для выполнения
   блокирующих вызовов POSIX асинхронно, в отдельных потоках. Для большинства
   вызовов существуют стандартные обёртки, которые вы можете найти
   в заголовочном файле `src/file.cc`, так что скорее всего вам не понадобится
   использовать эту библиотеку. Внутренние функции libeio можно посмотреть
   в файле `deps/libeio/eio.h` дистрибутива Node.

 - Внутренние библиотеки Node. Наиболее важная из них — класс `node::ObjectWrap`,
   от которого будут наследоваться большинство ваших классов.

 - Остальные доступные библиотеки вы можете найти впапке `deps` дистрибутива Node.

При сборке Node все её зависимости статически компилируются в исполняемый файл.
При сборке своего модуля вы не должны задумываться об описанных выше библиотеках.

В качестве простого примера сделаем дополнение для Node на C++, которое будет
делать тоже самое, что и JavaScript код:

    exports.hello = 'world';

Создадим файл `hello.cc`:

    #include <v8.h>

    using namespace v8;

    extern "C" void
    init (Handle<Object> target)
    {
      HandleScope scope;
      target->Set(String::New("hello"), String::New("world"));
    }

Этот код нужно собрать в файл `hello.node`, файл бинарного дополнения.
Для этого создадим файл `wscript`, содержащий код на Python (аналог Makefile):

    srcdir = '.'
    blddir = 'build'
    VERSION = '0.0.1'

    def set_options(opt):
      opt.tool_options('compiler_cxx')

    def configure(conf):
      conf.check_tool('compiler_cxx')
      conf.check_tool('node_addon')

    def build(bld):
      obj = bld.new_task_gen('cxx', 'shlib', 'node_addon')
      obj.target = 'hello'
      obj.source = 'hello.cc'

Теперь можно запустить команду `node-waf configure build`, которая создаст файл
`build/default/hello.node`, содержащий бинарную версию дополнения.

`node-waf` — расширение [WAF](http://code.google.com/p/waf/), системы сборки
на языке Python. `node-waf` включён в состав Node для упрощения процесса
сборки дополнений.

Каждое дополнение должно содержать функцию `init` со следующим интерфейсом:

    extern 'C' void init (Handle<Object> target)

На данный момент это вся документация по созданию дополнений. В качестве примера
вы можете просмотреть код [node_postgres](http://github.com/joyent/node_postgres).

